{
    "$schema": "./workflows.schema.json",
    "commandMapping": {
        "changelog": {
            "claude": "/changelog-update",
            "copilot": "/changelog-update"
        },
        "code": {
            "claude": "/code",
            "copilot": "/code"
        },
        "code-review": {
            "claude": "/review-codebase",
            "copilot": "/review/codebase"
        },
        "code-simplifier": {
            "claude": "/code-simplifier",
            "copilot": "/code-simplifier"
        },
        "cook": {
            "claude": "/cook",
            "copilot": "/cook"
        },
        "debug": {
            "claude": "/debug",
            "copilot": "/debug"
        },
        "dependency": {
            "claude": "/team-dependency",
            "copilot": "/team/dependency"
        },
        "design-spec": {
            "claude": "/team-design-spec",
            "copilot": "/team/design-spec"
        },
        "docs-update": {
            "claude": "/docs-update",
            "copilot": "/docs/update"
        },
        "feature-docs": {
            "claude": "/feature-docs",
            "copilot": "/feature-docs"
        },
        "fix": {
            "claude": "/fix",
            "copilot": "/fix"
        },
        "idea": {
            "claude": "/team-idea",
            "copilot": "/team/idea"
        },
        "investigate": {
            "claude": "/investigate",
            "copilot": "/investigate"
        },
        "plan": {
            "claude": "/plan",
            "copilot": "/plan"
        },
        "plan-review": {
            "claude": "/plan-review",
            "copilot": "/plan/review"
        },
        "plan-validate": {
            "claude": "/plan-validate",
            "copilot": "/plan/validate"
        },
        "prioritize": {
            "claude": "/team-prioritize",
            "copilot": "/team/prioritize"
        },
        "quality-gate": {
            "claude": "/team-quality-gate",
            "copilot": "/team/quality-gate"
        },
        "refine": {
            "claude": "/team-refine",
            "copilot": "/team/refine"
        },
        "review-changes": {
            "claude": "/review-changes",
            "copilot": "/review-changes"
        },
        "review-post-task": {
            "claude": "/review-post-task",
            "copilot": "/review-post-task"
        },
        "scout": {
            "claude": "/scout",
            "copilot": "/scout"
        },
        "status": {
            "claude": "/team-status",
            "copilot": "/team/status"
        },
        "story": {
            "claude": "/team-story",
            "copilot": "/team/story"
        },
        "team-sync": {
            "claude": "/team-team-sync",
            "copilot": "/team/team-sync"
        },
        "test": {
            "claude": "/test",
            "copilot": "/test"
        },
        "test-cases": {
            "claude": "/team-test-cases",
            "copilot": "/team/test-cases"
        },
        "test-initial": {
            "claude": "/test",
            "copilot": "/test"
        },
        "test-spec": {
            "claude": "/team-test-spec",
            "copilot": "/team/test-spec"
        },
        "watzup": {
            "claude": "/watzup",
            "copilot": "/watzup"
        },
        "why-review": {
            "claude": "/why-review",
            "copilot": "/why-review"
        }
    },
    "description": "Workflow automation configuration for Claude Code and GitHub Copilot — AI-native intent detection (v2)",
    "settings": {
        "allowOverride": true,
        "checkpoints": {
            "autoSaveOnCompact": true,
            "enabled": true,
            "filenamePattern": "checkpoint-{YYMMDD}-{HHMM}-{slug}.md",
            "intervalMinutes": 30,
            "path": "plans/reports"
        },
        "confirmHighImpact": true,
        "enabled": true,
        "overridePrefix": "quick:",
        "showDetection": true
    },
    "version": "2.0.0",
    "workflows": {
        "batch-operation": {
            "confirmFirst": false,
            "description": "Multi-file batch operations requiring progress tracking",
            "enableCheckpoints": true,
            "name": "Batch Operation",
            "preActions": {
                "injectContext": "BATCH OPERATION PROTOCOL:\n1. Plan: List ALL files to modify, define change pattern\n2. Validate plan — get user approval before bulk changes\n3. Why-review: Challenge whether batch change is necessary (vs per-file solutions)\n4. Implement: Apply changes file-by-file with progress tracking\n5. Code-simplifier: KISS/DRY/YAGNI pass on all changed files\n6. Run tests after batch to catch regressions\n7. Summary report with file count and change summary\n\nSAFETY:\n- ALWAYS list all affected files in plan before modifying\n- Use find-and-replace patterns, not manual edits\n- Checkpoint progress every 10 files\n- If any file fails, STOP and report before continuing"
            },
            "sequence": ["plan", "plan-review", "plan-validate", "why-review", "code", "code-simplifier", "review-changes", "test", "watzup"],
            "whenNotToUse": "Single-file changes, test file creation, documentation updates.",
            "whenToUse": "User wants to apply changes across multiple files, directories, or components at once. Includes batch updates, bulk renames, find-and-replace across codebase, merge/combine/consolidate multiple files or modules into one, or operations targeting 'all' or 'every' instance."
        },
        "bugfix": {
            "confirmFirst": false,
            "description": "Systematic debugging and fix workflow with investigation-first approach",
            "enableCheckpoints": true,
            "name": "Bug Fix",
            "preActions": {
                "injectContext": "BUG FIX PROTOCOL:\n1. Scout: Find files related to the reported issue\n2. Investigate: Understand current vs expected behavior\n3. Debug: Identify root cause with evidence (file:line)\n4. Plan fix with minimal blast radius\n5. Validate plan before implementing\n6. Validate fix rationale with /why-review\n7. Fix the identified issue\n8. Simplify code for readability and consistency\n9. Code review for quality and regression risk\n10. Update changelog\n11. Run tests to verify fix and no regressions\n12. Update documentation (general + feature docs via change detection)\n13. Summary report of fix and verification results\n- Guardrail: Fix root cause, not symptom\n- Guardrail: Minimal change scope — avoid refactoring during bug fix"
            },
            "sequence": ["scout", "investigate", "debug", "plan", "plan-review", "plan-validate", "why-review", "fix", "code-simplifier", "review-changes", "code-review", "changelog", "test", "docs-update", "watzup"],
            "whenNotToUse": "User wants new features, refactoring, documentation, or investigation without fixing.",
            "whenToUse": "User reports a bug, error, crash, broken functionality, or asks to fix/debug/troubleshoot an issue. Includes regression fixes, 'not working' reports, and exception traces."
        },
        "business-feature-docs": {
            "confirmFirst": false,
            "description": "Business feature documentation with 26-section template enforcement",
            "enableCheckpoints": true,
            "name": "Business Feature Documentation",
            "preActions": {
                "activateSkill": "business-feature-docs",
                "injectContext": "BUSINESS FEATURE DOC REQUIREMENTS:\n- 26 sections mandatory (see template)\n- Quick Navigation with Audience column\n- TC-XX-XXX test case format with GIVEN/WHEN/THEN\n- Evidence field with file:line format\n- Cross-reference parent features if sub-feature\n\nMANDATORY UPDATE CHECKLIST (when updating existing docs):\n- ALWAYS update test sections 17-20 when documenting new functionality\n- ALWAYS update CHANGELOG.md with feature entry\n- ALWAYS update Version History (Section 26) with new version entry",
                "readFiles": ["docs/templates/detailed-feature-docs-template.md"]
            },
            "sequence": ["scout", "investigate", "plan", "plan-review", "plan-validate", "docs-update", "review-changes", "review-post-task", "watzup"],
            "whenNotToUse": "General documentation updates, code comments, README changes.",
            "whenToUse": "User wants to create or update business feature documentation using the 26-section template. Includes module docs targeting docs/business-features/."
        },
        "deployment": {
            "confirmFirst": false,
            "description": "Deployment and CI/CD pipeline management",
            "enableCheckpoints": true,
            "name": "Deployment & Infrastructure",
            "preActions": {
                "activateSkill": "devops",
                "injectContext": "DEPLOYMENT WORKFLOW:\n1. Review infrastructure requirements\n2. Plan deployment strategy (Docker, K8s, CI/CD)\n3. Implement configuration changes\n4. Verify deployment readiness\n\nGUARDRAILS:\n- Always verify rollback strategy exists\n- Never modify production configs without explicit approval"
            },
            "sequence": ["scout", "investigate", "plan", "plan-review", "plan-validate", "code", "review-changes", "code-review", "test", "watzup"],
            "whenNotToUse": "Explaining deployment concepts, checking deployment status/history.",
            "whenToUse": "User wants to set up or modify deployment, infrastructure, CI/CD pipelines, Docker configuration, or deploy to environments."
        },
        "design-workflow": {
            "confirmFirst": false,
            "description": "Designer workflow: create design specification from requirements, hand off for review",
            "enableCheckpoints": false,
            "name": "Design Workflow",
            "preActions": {
                "activateSkill": "ui-ux-pro-max",
                "injectContext": "DESIGN WORKFLOW:\n1. Read requirements/PBI\n2. Create design spec with component inventory\n3. Document states, tokens, accessibility\n4. Review with code-review agent",
                "readFiles": ["docs/design-system/FrontendDesignSystem.md"]
            },
            "sequence": ["design-spec", "review-changes", "code-review", "watzup"],
            "whenNotToUse": "Implementing an existing design in code, coding from a spec.",
            "whenToUse": "User wants to create a UI/UX design specification, mockup, wireframe, or component spec from requirements."
        },
        "documentation": {
            "confirmFirst": false,
            "description": "Documentation creation and update workflow",
            "enableCheckpoints": true,
            "name": "Documentation Update",
            "preActions": {
                "injectContext": "DOCUMENTATION PROTOCOL:\n1. Identify all docs affected by recent changes\n2. Verify code examples compile and are accurate\n3. Update cross-references and navigation links\n4. Ensure consistent terminology across docs\n5. Match docs to current codebase state\n- Rules: Evidence-based (cite file:line), no stale content, match existing doc style\n- Output: Updated docs with verified code references"
            },
            "sequence": ["scout", "investigate", "plan", "plan-review", "plan-validate", "docs-update", "review-changes", "review-post-task", "watzup"],
            "whenNotToUse": "Business feature docs (use business-feature-docs), code implementation, test-only changes.",
            "whenToUse": "User wants to write, update, or improve general documentation, README, or code comments."
        },
        "e2e-testing": {
            "confirmFirst": false,
            "description": "E2E test creation, recording, and coverage gap analysis workflow using Playwright",
            "enableCheckpoints": true,
            "name": "E2E Testing",
            "preActions": {
                "activateSkill": "e2e-record",
                "injectContext": "E2E TESTING PROTOCOL:\n1. Read existing page objects in src/Frontend/e2e/page-objects/\n2. Read existing tests in src/Frontend/e2e/tests/ for patterns\n3. Use TC-{MOD}-{FEAT}-{NUM} format for test case IDs\n4. Use page objects — never raw selectors in test files\n5. Use test-helpers.ts for fixtures and api-helpers.ts for API calls\n6. Add priority tags: @P0 (smoke), @P1 (critical), @P2 (standard), @P3 (edge)\n- Guardrail: Never modify existing test logic — only add annotations or new tests\n- Guardrail: Always clean up test data in afterEach hooks"
            },
            "sequence": ["scout", "investigate", "plan", "plan-review", "plan-validate", "code", "review-changes", "code-review", "test", "watzup"],
            "whenNotToUse": "Unit tests, integration tests, API-only testing, test execution without creation.",
            "whenToUse": "User wants to create, record, or enhance E2E tests. Includes Playwright test creation, codegen recording, coverage gap analysis, TC-ID annotation, and E2E test refactoring."
        },
        "feature": {
            "confirmFirst": false,
            "description": "Full feature development workflow with planning, implementation, testing, and documentation",
            "enableCheckpoints": true,
            "name": "Feature Implementation",
            "preActions": {
                "injectContext": "FEATURE IMPLEMENTATION PROTOCOL:\n1. Search for existing patterns before creating new code\n2. Follow platform hierarchy: Entity > Service > Component\n3. Place business logic in lowest appropriate layer\n4. Use platform base classes (PlatformComponent, PlatformApiService, PlatformVmStore)\n5. Validate design rationale with /why-review before implementation\n6. Add changelog entry for user-facing changes\n- Rules: YAGNI (no speculative features), BEM for all UI elements, untilDestroyed() for subscriptions\n- Backend: CQRS Command+Result+Handler in ONE file, DTO owns mapping, side effects in Event Handlers\n- Guardrail: Provide file:line evidence of pattern search in plan"
            },
            "sequence": ["scout", "investigate", "plan", "plan-review", "plan-validate", "why-review", "cook", "code-simplifier", "review-changes", "code-review", "changelog", "test", "docs-update", "watzup"],
            "whenNotToUse": "Bug fixes, documentation-only, test-only, migration, refactoring, investigation.",
            "whenToUse": "User wants to implement, add, create, build, or develop a new feature, functionality, module, or component."
        },
        "full-feature-lifecycle": {
            "confirmFirst": true,
            "description": "Complete feature from idea to release with all role handoffs",
            "enableCheckpoints": true,
            "name": "Full Feature Lifecycle",
            "preActions": {
                "injectContext": "FULL FEATURE LIFECYCLE:\n1. PO captures idea\n2. BA refines and creates stories\n3. Designer creates design spec\n4. Dev plans and implements with plan validation\n5. QA generates test spec\n6. QC runs quality gate\n7. Update documentation (general + feature docs via change detection)\n8. Summary report\n9. PO signs off acceptance\n\nThis is an end-to-end workflow crossing all roles."
            },
            "sequence": ["idea", "refine", "story", "design-spec", "plan", "plan-review", "plan-validate", "cook", "review-changes", "test-spec", "quality-gate", "docs-update", "watzup"],
            "whenNotToUse": "Quick fixes, minor changes, single-role tasks.",
            "whenToUse": "Complete feature from idea to release with all role handoffs."
        },
        "idea-to-pbi": {
            "confirmFirst": false,
            "description": "PO/BA workflow: capture idea, refine to PBI, create stories, prioritize",
            "enableCheckpoints": true,
            "name": "Idea to PBI",
            "preActions": {
                "activateSkill": "product-owner",
                "injectContext": "IDEA-TO-PBI WORKFLOW:\n1. Capture idea with problem statement\n2. Refine into PBI with acceptance criteria\n3. Break into user stories (GIVEN/WHEN/THEN)\n4. Prioritize using RICE or MoSCoW"
            },
            "sequence": ["idea", "refine", "story", "prioritize", "watzup"],
            "whenNotToUse": "Bug fixes, code implementation, investigation.",
            "whenToUse": "User has a new product idea, feature request, or wants to add to the backlog. Includes refining ideas into PBIs and creating user stories."
        },
        "investigation": {
            "confirmFirst": false,
            "description": "Codebase exploration and understanding workflow",
            "enableCheckpoints": true,
            "name": "Code Investigation",
            "preActions": {
                "injectContext": "INVESTIGATION PROTOCOL:\n- DO NOT modify any files — read-only analysis\n- Trace code paths with evidence (file:line references)\n- Map dependencies and side effects\n- Declare confidence level for findings (<90% = flag uncertainty)\n- Output: Clear explanation with code evidence and dependency map"
            },
            "sequence": ["scout", "investigate"],
            "whenNotToUse": "Any task requiring code changes: implementing, fixing, refactoring, creating, updating, deleting, deploying, or writing documentation.",
            "whenToUse": "User asks how something works, where code is located, wants to understand or explore a codebase feature, trace code paths, or explain implementation details."
        },
        "migration": {
            "confirmFirst": false,
            "description": "Database schema and data migration workflow",
            "enableCheckpoints": true,
            "name": "Database Migration",
            "preActions": {
                "activateSkill": "easyplatform-backend",
                "injectContext": "DATABASE MIGRATION PROTOCOL:\n1. Analyze current schema and identify breaking changes\n2. Plan rollback strategy before implementation\n3. Use PlatformDataMigrationExecutor for data migrations\n4. Use EF migrations for schema changes\n5. Verify migration is idempotent (safe to re-run)\n- Guardrail: Always provide rollback path\n- Guardrail: Never delete data without backup strategy"
            },
            "sequence": ["scout", "investigate", "plan", "plan-review", "plan-validate", "code", "review-changes", "code-review", "test", "watzup"],
            "whenNotToUse": "Explaining migration concepts, checking migration history/status.",
            "whenToUse": "User wants to create or run database migrations: schema changes, data migrations, EF migrations, adding/removing/altering columns or tables."
        },
        "pbi-to-tests": {
            "confirmFirst": false,
            "description": "QA workflow: generate test spec from PBI, create detailed test cases, run quality gate",
            "enableCheckpoints": true,
            "name": "PBI to Tests",
            "preActions": {
                "activateSkill": "qa-engineer",
                "injectContext": "PBI-TO-TESTS WORKFLOW:\n1. Read PBI acceptance criteria\n2. Generate test specification with TC-{MOD}-{NNN} IDs\n3. Create detailed test cases with evidence\n4. Run pre-QA quality gate"
            },
            "sequence": ["test-spec", "test-cases", "quality-gate", "watzup"],
            "whenNotToUse": "Running existing tests, executing test suites.",
            "whenToUse": "User wants to create or generate test specs/cases from a PBI, feature, or story. Includes QA test generation."
        },
        "performance": {
            "confirmFirst": false,
            "description": "Performance analysis and optimization workflow",
            "enableCheckpoints": true,
            "name": "Performance Optimization",
            "preActions": {
                "activateSkill": "performance",
                "injectContext": "PERFORMANCE WORKFLOW:\n1. Profile and identify bottlenecks\n2. Analyze root causes\n3. Plan optimization strategy\n4. Validate plan assumptions\n5. Implement changes\n6. Verify with benchmarks"
            },
            "sequence": ["scout", "investigate", "plan", "plan-review", "plan-validate", "code", "review-changes", "code-review", "test", "watzup"],
            "whenNotToUse": "Explaining performance concepts, checking performance reports/history.",
            "whenToUse": "User wants to analyze or optimize performance: fix slow queries, reduce latency, improve throughput, resolve N+1 problems, address bottlenecks."
        },
        "pm-reporting": {
            "confirmFirst": false,
            "description": "PM workflow: generate status report and dependency analysis",
            "enableCheckpoints": false,
            "name": "PM Reporting",
            "preActions": {
                "activateSkill": "project-manager",
                "injectContext": "PM REPORTING WORKFLOW:\n1. Gather sprint/project data\n2. Generate status report with metrics\n3. Analyze dependencies and blockers\n4. Output to plans/reports/"
            },
            "sequence": ["status", "dependency"],
            "whenNotToUse": "Git status, commit status, PR status, build status, quick one-line status checks.",
            "whenToUse": "User wants a status report, sprint update, project progress report, blocker analysis, or comprehensive project overview."
        },
        "pre-development": {
            "confirmFirst": false,
            "description": "Quality gate and planning before starting development",
            "enableCheckpoints": false,
            "name": "Pre-Development Setup",
            "preActions": {
                "activateSkill": "plan",
                "injectContext": "PRE-DEVELOPMENT WORKFLOW:\n1. Run quality-gate checks (ensure clean slate)\n2. Create implementation plan\n3. Review plan for quality and completeness\n4. Validate plan with critical questions"
            },
            "sequence": ["quality-gate", "plan", "plan-review", "plan-validate"],
            "whenNotToUse": "Already in development, just wanting to explain pre-development concept.",
            "whenToUse": "User wants to prepare before starting development: quality gate checks, setup for new feature work, kick off a new feature, pre-coding preparation."
        },
        "quality-audit": {
            "confirmFirst": false,
            "description": "Quality audit workflow: review code for best practices, plan fixes, implement improvements, verify with tests",
            "enableCheckpoints": true,
            "name": "Quality Audit",
            "preActions": {
                "injectContext": "QUALITY AUDIT PROTOCOL:\n1. Review code against platform patterns and best practices\n2. Identify defects with severity (Critical/Major/Minor)\n3. CRITICAL GATE: Present findings to user BEFORE implementing fixes\n4. Fix only approved items\n5. Verify each fix with tests\n- Rules: Evidence-based findings (file:line), no speculative improvements, fix what's broken not what's different"
            },
            "sequence": ["code-review", "plan", "plan-review", "plan-validate", "code", "review-changes", "test", "watzup"],
            "whenNotToUse": "Reviewing uncommitted changes (use review-changes), PR review, bug fixes.",
            "whenToUse": "User wants a quality audit: review code for best practices, ensure no flaws, verify quality standards, audit-and-fix workflow, systematic review, or review project configuration/settings quality (e.g., CI/CD config, linter settings, AI agent settings, hooks quality, MCP servers, tooling configuration). Also matches: 'review X quality', 'ensure best practices', 'no enhancement needed', 'audit hooks/settings/config'."
        },
        "refactor": {
            "confirmFirst": false,
            "description": "Code improvement and restructuring workflow",
            "enableCheckpoints": true,
            "name": "Code Refactoring",
            "preActions": {
                "injectContext": "REFACTORING PROTOCOL:\n1. Define refactoring scope and expected outcomes\n2. CHECKPOINT: If removing code, run /investigate-removal first\n3. Verify all tests pass BEFORE refactoring\n4. Validate design rationale with /why-review\n5. Apply incremental changes — one concern at a time\n6. Verify tests pass AFTER each change\n7. No behavior changes — same inputs produce same outputs\n8. Update documentation (general + feature docs via change detection)\n- Guardrail: Never change behavior during refactoring\n- Guardrail: Follow platform hierarchy (Entity > Service > Component)"
            },
            "sequence": ["scout", "investigate", "plan", "plan-review", "plan-validate", "why-review", "code", "code-simplifier", "review-changes", "code-review", "changelog", "test", "docs-update", "watzup"],
            "whenNotToUse": "Bug fixes, new features, quality audits.",
            "whenToUse": "User wants to refactor, restructure, reorganize, clean up code, improve code quality, extract methods, rename, split/merge components, or address technical debt."
        },
        "release-prep": {
            "confirmFirst": false,
            "description": "Quality gate checks and status report before release",
            "enableCheckpoints": true,
            "name": "Release Preparation",
            "preActions": {
                "activateSkill": "project-manager",
                "injectContext": "RELEASE PREPARATION PROTOCOL:\n1. Run pre-release quality gate — check:\n   - Open PRs awaiting merge\n   - Failing tests or builds\n   - Code review completeness\n   - CHANGELOG.md up-to-date\n   - No known critical/major bugs\n2. Generate status report with pass/fail per criterion\n3. Output: PASS (clear to release) or FAIL with blocking items"
            },
            "sequence": ["quality-gate", "status"],
            "whenNotToUse": "Git release commands, npm publish, release notes generation, release branch management.",
            "whenToUse": "User wants to prepare for a release: pre-release checks, release readiness, deployment checklist, go-live verification."
        },
        "review": {
            "confirmFirst": false,
            "description": "Code review and quality check workflow",
            "name": "Code Review",
            "preActions": {
                "injectContext": "CODE REVIEW PROTOCOL:\n- Severity levels: CRITICAL (must fix), MAJOR (should fix), MINOR (nice to have), NOTE (informational)\n- Check: Security (OWASP), performance (N+1, memory leaks), correctness, maintainability\n- Verify: Platform patterns compliance, BEM naming, proper base class usage\n- Output: Structured findings with file:line references and suggested fixes"
            },
            "sequence": ["code-review", "watzup"],
            "whenNotToUse": "Reviewing uncommitted/staged changes (use review-changes), reviewing plans/designs/docs, quality audits with fixes.",
            "whenToUse": "User wants a code review, PR review, code quality check, or audit of specific code or changes."
        },
        "review-changes": {
            "confirmFirst": false,
            "description": "Review uncommitted changes before commit",
            "name": "Review Changes",
            "preActions": {
                "injectContext": "PRE-COMMIT REVIEW:\n- Review all staged and unstaged changes\n- Check for: security issues, debug artifacts (console.log, debugger), incomplete code, style violations\n- Verify no sensitive files (.env, credentials) are staged\n- Report findings with file:line references\n- Output: PASS (safe to commit) or ISSUES FOUND (with list)"
            },
            "sequence": ["review-changes"],
            "whenNotToUse": "PR reviews, codebase reviews, branch comparisons",
            "whenToUse": "User wants to review current uncommitted, staged, or unstaged changes before committing"
        },
        "security-audit": {
            "confirmFirst": false,
            "description": "Security review and vulnerability assessment",
            "enableCheckpoints": true,
            "name": "Security Audit",
            "preActions": {
                "activateSkill": "arch-security-review",
                "injectContext": "SECURITY AUDIT WORKFLOW:\n1. Scan for OWASP Top 10 vulnerabilities\n2. Review authentication and authorization patterns\n3. Check input validation and sanitization\n4. Assess data protection and encryption\n5. Report findings with severity ratings\n\nGUARDRAILS:\n- Read-only analysis unless fix is approved\n- Use CVSS scoring for severity\n- Check both frontend and backend attack surfaces"
            },
            "sequence": ["scout", "investigate", "watzup"],
            "whenNotToUse": "Implementing new security features, fixing known security bugs.",
            "whenToUse": "User wants a security audit: vulnerability assessment, OWASP check, security review, penetration test analysis."
        },
        "sprint-planning": {
            "confirmFirst": false,
            "description": "Comprehensive sprint planning: prioritize backlog, analyze dependencies, prepare team sync",
            "enableCheckpoints": true,
            "name": "Sprint Planning Session",
            "preActions": {
                "activateSkill": "product-owner",
                "injectContext": "SPRINT PLANNING:\n1. /prioritize - Review and prioritize backlog\n2. /dependency - Check blockers and dependencies\n3. /team-sync - Generate planning meeting agenda"
            },
            "sequence": ["prioritize", "dependency", "team-sync"],
            "whenNotToUse": "Sprint review, retrospective, sprint status report, end-of-sprint activities.",
            "whenToUse": "User wants to plan a sprint: prioritize backlog, analyze dependencies, prepare team sync, iteration planning, or sprint kickoff."
        },
        "testing": {
            "confirmFirst": false,
            "description": "Test creation and execution workflow",
            "name": "Testing",
            "preActions": {
                "injectContext": "TEST EXECUTION:\n- Run relevant test suites for the current context\n- Report results with pass/fail counts and failure details\n- For failing tests, include file:line and error message\n- Suggest fixes for failures when root cause is clear"
            },
            "sequence": ["test"],
            "whenNotToUse": "Test specification creation (use pbi-to-tests), test case generation from PBI.",
            "whenToUse": "User wants to run test suites, check test coverage, or execute tests."
        },
        "verification": {
            "confirmFirst": false,
            "description": "Investigation-first verification: understand scope, test/validate, report findings, conditionally plan fix with approval",
            "enableCheckpoints": true,
            "name": "Verification & Validation",
            "preActions": {
                "injectContext": "VERIFICATION PROTOCOL:\n1. Define expected behavior — what 'correct' means\n2. Reproduce the scenario under test\n3. Verify with evidence (test output, logs, code traces)\n4. CRITICAL GATE: STOP and report to user — PASS or FAIL with evidence\n5. If issue found and user approves: plan fix, validate, implement\n6. If no issue: document verification evidence\n7. Update documentation (general + feature docs via change detection)\n- Guardrail: Evidence-based verification — never assume correctness without proof"
            },
            "sequence": ["scout", "investigate", "test-initial", "plan", "plan-review", "plan-validate", "fix", "code-simplifier", "review-changes", "code-review", "test", "docs-update", "watzup"],
            "whenNotToUse": "New feature implementation, code review, documentation, investigation-only, quality audits.",
            "whenToUse": "User wants to verify, validate, confirm, check that something works correctly, or ensure expected behavior. Includes 'make sure', 'ensure that', 'verify changes', 'ensure no flaws', and 'must work as expected' requests. Takes priority over review-changes when intent is verification/validation rather than read-only review."
        }
    }
}
