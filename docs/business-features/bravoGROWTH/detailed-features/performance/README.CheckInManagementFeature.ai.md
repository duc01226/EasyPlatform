# Check-In Management Feature - AI Context

> AI-optimized context file for code generation tasks.
> Full documentation: [README.CheckInManagementFeature.md](./README.CheckInManagementFeature.md)
> Last synced: 2026-01-11

---

## Quick Reference

| Field | Value |
|-------|-------|
| Module | bravoGROWTH |
| Service | Growth.Service (PostgreSQL) |
| Database | PostgreSQL |
| Schema | CheckIn (dbo.CheckIn_* tables) |

### File Locations

```
Entities:    src/Services/bravoGROWTH/Growth.Domain/Entities/CheckIn/
Commands:    src/Services/bravoGROWTH/Growth.Application/UseCaseCommands/CheckIn/
Queries:     src/Services/bravoGROWTH/Growth.Application/UseCaseQueries/CheckIns/
Controllers: src/Services/bravoGROWTH/Growth.Service/Controllers/CheckInController.cs
Frontend:    src/WebV2/apps/growth-for-company/src/app/routes/check-ins/
            src/WebV2/apps/employee/src/app/routes/check-in/
API Service: src/WebV2/libs/bravo-domain/src/check-in/api/check-ins-api.service.ts
```

---

## Domain Model

### Entities

```
CheckInSeriesSetting : RootAuditedEntity<CheckInSeriesSetting, string, string>
├── Id: string (ULID)
├── CompanyId: string
├── TargetEmployeeId: string (employee being checked in)
├── CheckingEmployeeId: string (manager/leader conducting)
├── StartDate: DateTime (UTC)
├── EndDate: DateTime? (null = ongoing)
├── TimeZone: TimeZoneInfo
├── DurationInMinutes: int (default: 30)
├── Frequency: CheckInFrequency (OneTimeOnly | EveryWeek | EveryMonth | etc.)
├── FrequencyInfo: FrequencyInfos (WeeklyDay, MonthlyDay)
├── DefaultTitle: LanguageString (multi-language)
├── IsTitleAutogenerated: bool
├── IsQuickCheckIn: bool (no notifications/calendar)
├── DefaultDiscussionPointIds: List<string>
└── LastMessageSyncDate: DateTime

CheckInEvent : RootAuditedEntity<CheckInEvent, string, string>
├── Id: string (ULID)
├── CompanyId: string
├── TargetEmployeeId: string
├── CheckingEmployeeId: string
├── CheckInDate: DateTime (UTC)
├── TimeZone: TimeZoneInfo
├── DurationInMinutes: int
├── Status: CheckInStatuses (Incomplete | Completed)
├── Title: LanguageString
├── IsTitleAutogenerated: bool
├── IsQuickCheckIn: bool
├── CheckInSeriesSettingId: string? (null = one-time)
├── ExternalCalendarEventId: string? (MS Calendar/Google)
├── DiscussionPoints: List<CheckInEventDiscussionPoint> (navigation)
├── Notes: List<CheckInEventNote> (navigation)
├── TargetEmployee: Employee? (navigation)
├── CheckingEmployee: Employee? (navigation)
└── CheckInSeriesSetting: CheckInSeriesSetting? (navigation)
```

### Value Objects

```
CheckInEventDiscussionPoint {
  Id: string?,
  DiscussionPointId: string (FK),
  IsCompleted: bool,
  Position: int,
  DiscussionPoint: DiscussionPoint? (navigation)
}

CheckInEventNote {
  Id: string?,
  Detail: string (markdown supported),
  IsPrivate: bool (private = author only, shared = all participants),
  OwnerEmployeeId: string (note author),
  CreatedDate: DateTime,
  LastUpdatedDate: DateTime?
}

FrequencyInfos {
  Frequency: CheckInFrequency,
  WeeklyDay: DayOfWeek? (Mon-Sun for EveryWeek),
  MonthlyDay: int? (1-31 for EveryMonth)
}

LanguageString {
  LanguageValues: List<LocalizedString> { key: "en", value: "Weekly Check-in" },
  DefaultValue: string
}
```

### Enums

```
CheckInStatuses: Incomplete=1 | Completed=2
CheckInFrequency:
  OneTimeOnly=0 | EveryWeek=1 | Every2Weeks=2 | EveryMonth=3 |
  Every2Months=4 | Every3Months=5 | Every4Months=6 | Every6Months=7 | EveryYear=8
```

### Key Expressions

```csharp
// Company-scoped
public static Expression<Func<CheckInEvent, bool>> ByCompanyExpr(string companyId)
    => e => e.CompanyId == companyId;

// Target employee
public static Expression<Func<CheckInEvent, bool>> ByEmployeeExpr(string employeeId)
    => e => e.TargetEmployeeId == employeeId;

// Status filter
public static Expression<Func<CheckInEvent, bool>> ByStatusExpr(CheckInStatuses status)
    => e => e.Status == status;

// Upcoming check-ins (future + incomplete)
public static Expression<Func<CheckInEvent, bool>> UpcomingCheckInsExpr()
    => e => e.CheckInDate > DateTime.UtcNow && e.Status == CheckInStatuses.Incomplete;

// User is participant
public static Expression<Func<CheckInEvent, bool>> IsParticipantInCheckInsExpr(string employeeId)
    => e => e.TargetEmployeeId == employeeId || e.CheckingEmployeeId == employeeId;
```

---

## API Contracts

### Commands

```
POST /api/CheckIn
├── Request:  SaveCheckInCommand {
│              targetEmployeeId, checkingEmployeeId?, checkInDate,
│              timeZone, durationInMinutes, frequencyInfo, defaultTitle,
│              isTitleAutogenerated, isQuickCheckIn, newDiscussionPoints[]
│            }
├── Response: SaveCheckInCommandResult { savedCheckIn: CheckInEventDto }
├── Handler:  SaveCheckInCommandHandler.cs
└── Evidence: SaveCheckInCommand.cs:17-32

POST /api/CheckIn/partial-update
├── Request:  PartialUpdateCheckInCommand {
│              checkInEventId, toReplaceDiscussionPoints[],
│              toSaveNotes[], toDeleteCheckInEventNoteIds[]
│            }
├── Response: PartialUpdateCheckInCommandResult {
│              checkInEventId, replacedDiscussionPoints[],
│              savedNotes[], deletedCheckInEventNoteIds[]
│            }
├── Handler:  PartialUpdateCheckInCommandHandler.cs
└── Evidence: PartialUpdateCheckInCommand.cs:18-42

POST /api/CheckIn/update-status
├── Request:  UpdateCheckInStatusCommand {
│              checkInEventId, toUpdateStatus: "Completed"
│            }
├── Response: UpdateCheckInStatusCommandResult {
│              checkInEventId, updatedStatus
│            }
├── Handler:  UpdateCheckInStatusCommandHandler.cs
└── Evidence: UpdateCheckInStatusCommand.cs:14-32

POST /api/CheckIn/delete
├── Request:  DeleteCheckInCommand {
│              checkInEventId, deleteType: "SingleCheckIn" | "SeriesAndFollowingCheckIn"
│            }
├── Response: 204 No Content
├── Handler:  DeleteCheckInCommandHandler.cs
└── Evidence: DeleteCheckInCommand.cs:14-25
```

### Queries

```
GET /api/CheckIn
├── Params:   targetEmployeeId?, checkingEmployeeId?, isUpcomingCheckIn?,
│             isParticipantInCheckIns?, beforeDate?, afterDate?,
│             skipCount, maxResultCount, orderDirection
├── Response: PagedResultDto<CheckInEventDto> { totalCount, items[] }
├── Handler:  GetCheckInListQueryHandler.cs
└── Evidence: CheckInController.cs:47-51

GET /api/CheckIn/{id}
├── Response: CheckInEventDto {
│              id, targetEmployeeId, checkingEmployeeId, checkInDate,
│              durationInMinutes, status, title, discussionPoints[], notes[]
│            }
├── Handler:  GetCheckInEventRequestQueryHandler.cs
└── Evidence: CheckInController.cs:53-61

GET /api/CheckIn/dashboard-summary
├── Params:   fromDate, toDate, orgUnitIds?
├── Response: CheckInDashboardSummaryDto {
│              totalCheckIns, completedCheckIns, incompleteCheckIns,
│              scheduleCheckInsCount, upcomingCheckInsCount,
│              overdueCheckInsCount, completedPercentage
│            }
├── Handler:  GetCheckInDashboardSummaryQueryHandler.cs
└── Evidence: CheckInController.cs:82-86

GET /api/CheckIn/dashboard-organization
├── Response: List<OrganizationCheckInDto> {
│              id, name, totalCheckIns, completedCheckIns,
│              incompleteCheckIns, childOrgUnits[]
│            }
├── Handler:  GetOrganizationWithCheckInsDashboardInfoQueryHandler.cs
└── Evidence: CheckInController.cs:88-93

GET /api/CheckIn/dashboard-team
├── Params:   managerId, skipCount, maxResultCount
├── Response: PagedResultDto<DirectReportCheckInDto> {
│              employeeId, employeeName, lastCheckInDate,
│              nextCheckInDate, totalCheckIns, completedCheckIns
│            }
├── Handler:  GetDirectReportCheckInsDashboardQueryHandler.cs
└── Evidence: CheckInController.cs:95-100
```

### DTOs

```
CheckInEventDto : PlatformEntityDto<CheckInEvent, string>
├── Id: string?
├── CompanyId: string
├── TargetEmployeeId: string
├── CheckingEmployeeId: string
├── CheckInDate: DateTime
├── TimeZone: string
├── DurationInMinutes: int
├── Status: CheckInStatuses
├── Title: LocalizableStringDto
├── DiscussionPoints: List<CheckInEventDiscussionPointDto>
├── Notes: List<CheckInEventNoteDto>
└── MapToEntity(): CheckInEvent
```

---

## Validation Rules

| Rule | Constraint | Evidence |
|------|------------|----------|
| BR-CI-001 | Check-in created → send notification emails UNLESS isQuickCheckIn=true | `SaveCheckInCommand.cs:Validate()` |
| BR-CI-002 | Check-in created → create calendar event UNLESS isQuickCheckIn=true | `SaveCheckInCommand.cs:Validate()` |
| BR-CI-003 | External user selected → reject "External users can't participate" | `SaveCheckInCommand.cs:Validate()` |
| BR-CI-004 | Organizer = Participant → reject "Cannot be same person" | `SaveCheckInCommand.cs:Validate()` |
| BR-CI-005 | DefaultTitle not provided → reject "Title required" | `SaveCheckInCommand.cs:Validate()` |
| BR-REC-001 | EveryWeek frequency → generate events for 12 weeks ahead | `CheckInSeriesSetting.cs:GenerateCheckInEvents()` |
| BR-REC-002 | EveryMonth frequency → respect MonthlyDay, handle month-end (31→28-31) | `CheckInSeriesSetting.cs:CalculateNextMonthlyDate()` |
| BR-UPD-001 | Discussion points updated → replace entire list (add, update, delete) | `PartialUpdateCheckInCommand.cs:Validate()` |
| BR-UPD-002 | Check-in Status = Completed → reject updates "Already wrapped up" | `PartialUpdateCheckInCommandHandler.cs:ValidateCanBeUpdated()` |
| BR-DEL-001 | Delete single check-in → soft-delete event, series remains | `DeleteCheckInCommandHandler.cs:DeleteSingleEvent()` |
| BR-DEL-002 | Delete series → delete all future events, update series EndDate | `DeleteCheckInCommandHandler.cs:DeleteSeriesAndFollowing()` |
| BR-MGR-001 | Employee manager changed → update CheckInSeriesSetting.CheckingEmployeeId | `UpdateCheckInSettingsWithEndDateOnUpdateManagerOfEmployeeHandler.cs` |

### Validation Patterns

```csharp
// Command validation
public override PlatformValidationResult<IPlatformCqrsRequest> Validate()
    => base.Validate()
        .And(_ => TargetEmployeeId.IsNotNullOrEmpty(), "Target employee required")
        .And(_ => !IsExternalUser(TargetEmployeeId), "External users cannot participate")
        .And(_ => TargetEmployeeId != CheckingEmployeeId, "Organizer and participant cannot be same")
        .And(_ => DefaultTitle != null, "DefaultTitle required");

// Handler validation (async)
protected override async Task<PlatformValidationResult<T>> ValidateRequestAsync(...)
    => await validation
        .AndAsync(r => repository.AnyAsync(CheckInEvent.ByCompanyExpr(companyId), ct), "Company exists")
        .AndNotAsync(r => IsCheckInCompleted(r.CheckInEventId, ct), "Cannot update completed check-in");
```

---

## Service Boundaries

### Produces Events

```
CheckInEvent (via domain events)
├── When: Create, Update, Delete
├── Handlers:
│   ├── SendEmailOnCreateNewCheckInRequestEntityEventHandler → emails
│   ├── HandleExternalCalendarOnCheckInEntityEventHandler → calendar sync
│   ├── UpdateEmployeeNextCheckInDateByCheckInEventChangedEventHandler → Employee.NextCheckInDate
│   └── DeleteUpComingCheckInsOnDeleteCheckInsEmployeeEntityEventHandler (cascade)
└── Idempotent: Yes
```

### Background Jobs

```
AutoInitCheckInEventBackgroundJobExecutor
├── Schedule: Daily 00:10 UTC, runs on startup
├── Purpose: Generate future check-in events from series settings
├── Frequencies: EveryWeek, Every2Weeks, EveryMonth, Every3Months, Every6Months, EveryYear
├── Max events ahead: 3 months
├── Batch size: 50 series per iteration
└── Evidence: BackgroundJobs/CheckIns/AutoInitCheckInEventBackgroundJobExecutor.cs:15-36

AutoSendReminderForUpcomingCheckInBackgroundJobExecutor
├── Triggered by: AutoInitCheckInEvent job
├── Purpose: Send reminder notifications (configurable days before)
└── Evidence: BackgroundJobs/CheckIns/AutoSendReminderForUpcomingCheckInBackgroundJobExecutor.cs

SendReminderCheckInTodayBackgroundJobExecutor
├── Purpose: Send day-of reminders to both participants
├── Scheduled for: Specific check-in events
└── Evidence: BackgroundJobs/CheckIns/SendReminderCheckInTodayBackgroundJobExecutor.cs:10-49
```

---

## Critical Paths

### Create Check-In Series

```
1. Validate input (BR-CI-003, BR-CI-004, BR-CI-005)
   ├── Target employee non-external
   ├── Organizer ≠ Participant
   └── DefaultTitle provided
2. If recurring: Create CheckInSeriesSetting
3. Generate initial + future CheckInEvents (up to 12)
   ├── Apply frequency (EveryWeek, EveryMonth, etc.)
   └── Respect EndDate if set
4. For each event (unless isQuickCheckIn):
   ├── Send notification emails
   └── Create external calendar event
5. Repository.CreateAsync() triggers domain events
6. Background job (00:10 UTC) generates remaining future events
```

### Update Discussion Points & Notes

```
1. Load CheckInEvent with relations
2. Validate permission (participant or admin)
3. Validate Status ≠ Completed
4. Replace discussion points:
   ├── Delete omitted points
   ├── Insert new points
   └── Update existing points with new completed status + position
5. Upsert notes:
   ├── Insert new notes (null Id)
   ├── Update existing notes (has Id)
   └── Delete notes in toDeleteCheckInEventNoteIds
6. Save to repository
7. Domain events trigger notifications
```

### Mark Check-In as Completed

```
1. Load CheckInEvent
2. Validate permission (participant or admin)
3. Update Status: Incomplete → Completed
4. Lock further edits (validation blocks updates)
5. Save to repository
6. Dashboard metrics auto-update
7. No more changes allowed to this check-in
```

### Delete Check-In (Single or Series)

```
If SingleCheckIn:
  1. Soft-delete the event only
  2. Series remains active, continues generating

If SeriesAndFollowingCheckIn:
  1. Delete all CheckInEvents where CheckInDate >= current
  2. Update series.EndDate to before current event date
  3. Series no longer generates new events
  4. Send cancellation emails to participants
```

---

## Authorization & Permissions

### Authorization Policies

| Policy | Applies To |
|--------|-----------|
| `EmployeePolicy` | All check-in endpoints (minimum) |
| `CheckInPolicy` | All check-in endpoints (subscription active) |
| `LeaderOrLineManagerPolicy` | Delete operations (Admin, HrManager, OrgUnitManager) |

**Evidence**: `CheckInController.cs:16-17, 75`

### Permission Matrix

| Action | Admin | HrManager | OrgUnitMgr | Manager | Employee |
|--------|:----:|:---------:|:----------:|:-------:|:--------:|
| View all check-ins | ✅ | ✅ | ✅ | ✅ | ✅ (own only) |
| View org dashboard | ✅ | ✅ | ✅ (org) | ❌ | ❌ |
| View team dashboard | ✅ | ✅ | ✅ (reports) | ✅ (reports) | ❌ |
| Schedule check-in | ✅ | ✅ | ✅ (org) | ✅ (reports) | ❌ |
| Update discussion points | ✅ | ✅ | ✅ | ✅ | ✅ (participant) |
| Mark completed | ✅ | ✅ | ✅ | ✅ | ✅ (participant) |
| Delete check-in | ✅ | ✅ | ✅ | ✅ (own) | ❌ |
| View private notes | ✅ | ✅ | ✅ | ✅ (own) | ✅ (own) |

**Evidence**: `CheckInEvent.cs:156-163`, `PartialUpdateCheckInCommandHandler.cs:92-95`

---

## Performance Optimization

### Database Indexes

```
CheckInEvent:
  - (CompanyId, CheckInDate DESC)
  - (TargetEmployeeId)
  - (CheckingEmployeeId)
  - (Status)

CheckInSeriesSetting:
  - (CompanyId, TargetEmployeeId)
  - (EndDate) - for active series detection
```

### Query Optimization

```csharp
// Use query builder to compose filters
var qb = repository.GetQueryBuilder((uow, q) => q
    .Where(CheckInEvent.ByCompanyExpr(companyId))
    .WhereIf(statuses.Any(), e => statuses.Contains(e.Status))
    .OrderByDescending(e => e.CheckInDate));

// Batch load related entities (N+1 prevention)
var items = await repository.GetAllAsync(
    (uow, q) => qb(uow, q).PageBy(skip, take),
    ct,
    loadRelatedEntities: e => e.TargetEmployee!, e => e.CheckingEmployee!
);
```

### Performance Targets

| Operation | Target | Status |
|-----------|--------|--------|
| Create check-in (one-time) | < 2 seconds | ✅ 1.2s |
| Create series (12 events) | < 5 seconds | ✅ 3.8s |
| Load check-in list (20 items) | < 1 second | ✅ 0.6s |
| Dashboard statistics query | < 2 seconds | ✅ 1.4s |
| Organization hierarchy query | < 3 seconds | ✅ 2.1s |
| Background job (1000 series) | < 10 seconds | ✅ 8.5s |

---

## Critical Test Cases (P0)

| ID | Test | Validation |
|----|------|------------|
| TC-CI-001 | Create check-in series (weekly) | Series created, 12 events generated, emails sent | `SaveCheckInCommand.cs` |
| TC-CI-002 | Create duplicate participant | Returns validation error "External users..." | `SaveCheckInCommand.cs:Validate()` |
| TC-CI-003 | Update completed check-in | Returns error "Already wrapped up" | `PartialUpdateCheckInCommandHandler.cs` |
| TC-CI-004 | Delete single check-in | Event deleted, series continues | `DeleteCheckInCommandHandler.cs:DeleteSingleEvent()` |
| TC-CI-005 | Delete series and following | Future events deleted, series EndDate updated | `DeleteCheckInCommandHandler.cs:DeleteSeriesAndFollowing()` |
| TC-CI-006 | Mark check-in as completed | Status = Completed, further updates blocked | `UpdateCheckInStatusCommandHandler.cs` |
| TC-CI-007 | Update discussion points | Points replaced, completed status tracked | `PartialUpdateCheckInCommandHandler.cs` |
| TC-CI-008 | Add private/shared notes | Notes saved with correct visibility | `PartialUpdateCheckInCommandHandler.cs` |
| TC-CI-009 | Background job generates future | Events auto-generated daily at 00:10 UTC | `AutoInitCheckInEventBackgroundJobExecutor.cs` |
| TC-CI-010 | Manager changed | New manager assigned to series | `UpdateCheckInSettingsWithEndDateOnUpdateManagerOfEmployeeHandler.cs` |

### Edge Cases

| Scenario | Expected | Evidence |
|----------|----------|----------|
| Delete external user check-in | Cascade delete all check-ins | `DeleteUpComingCheckInsOnDeleteCheckInsEmployeeEntityEventHandler.cs` |
| Monthly recurrence on month-end (31st) | Feb adjusts to 28/29 | `CheckInSeriesSetting.cs:CalculateNextMonthlyDate()` |
| Quick check-in (silent mode) | No emails, no calendar sync | `CheckInEvent.cs:IsQuickCheckIn` |
| Non-existent check-in update | Returns 404 | `PartialUpdateCheckInCommandHandler.cs:EnsureFound()` |
| Concurrent updates to same check-in | Last write wins | Database constraint |

---

## Usage Notes

### When to Use This File

- Implementing check-in feature enhancements
- Fixing bugs in series generation or notifications
- Adding new dashboard views or filters
- Debugging cross-service sync issues
- Understanding entity relationships and workflows

### When to Use Full Documentation

- Business requirements clarification
- UI/UX design decisions
- Complete test planning
- Stakeholder presentations
- Operational runbook reference

---

*Generated from comprehensive documentation. For full details, see [README.CheckInManagementFeature.md](./README.CheckInManagementFeature.md)*
